using Godot;
using System;
using System.Linq;
using System.Collections.Generic;

public class RegionManager : Node2D
{
    private static RegionManager Instance;

    public static event Action<Vector2, Vector2, byte, byte> OnMapCreated;

    [Export] public byte MapWidth;
    [Export] public byte MapHeight;

    public Vector2 MapSize { get; private set; }
    public Vector2 MapCenter => MapSize / 2f;

    public Dictionary<int, Region> Regions;

    private Dictionary<int, Region> unoccupiedRegions;

    public RegionManager()
    {
        if (Instance != null) return;
        Instance = this;

        Regions = new Dictionary<int, Region>();
        unoccupiedRegions = new Dictionary<int, Region>();
    }

    public override void _Ready()
    {
        Region.OnRegionOccupied += HandleRegionOccupied;

        CreateMap(MapWidth, MapHeight);
    }

    public override void _ExitTree()
    {
        Region.OnRegionOccupied -= HandleRegionOccupied;
    }

    private void CreateMap(byte width, byte height)
    {
        MapSize = new Vector2(0, 0);
        PackedScene scene = GD.Load("region/region.tscn") as PackedScene;
        float regionWidth = 1;
        float regionHeight = 1;
        for (int j = 0; j < height; j++)
        {
            for (int i = 0; i < width; i++)
            {
                Region region = scene.Instance() as Region;
                region.Scale = new Vector2(25, 25);
                region.SetNeighbours(GetNeighbours(region.Id));
                // Note that this would be completely irrelevant 
                // If we were to have other region shapes than squares
                Sprite border = region.GetNode("visuals/border") as Sprite;
                
                regionWidth = border.Texture.GetWidth() * region.Scale.x;
                regionHeight = border.Texture.GetHeight() * region.Scale.y;
                region.GlobalPosition = new Vector2(
                    (regionWidth / 2f) + regionWidth * i,
                    (regionHeight / 2f) + regionHeight * j);

                unoccupiedRegions.Add(region.Id, region);
                Regions.Add(region.Id, region);
                AddChild(region);
            }
        }
        MapSize = new Vector2(MapWidth * regionWidth, MapHeight * regionHeight);
        OnMapCreated?.Invoke(MapSize, MapCenter, MapWidth, MapHeight);
    }

    /// <summary>
    /// This function only works if map is generated by the CreateMap() function
    /// And the map is generated row by row, meaning consecutive regions are also consecutive in ids
    /// </summary>
    /// <param name="id"></param>
    /// <returns></returns>
    private int[] GetNeighbours(int id)
    {
        List<int> neighbours = new List<int>();

        // Right / Left
        if (IdIsInMap(id + 1) && id + 1 >= 0) neighbours.Add(id + 1);
        if (IdIsInMap(id - 1) && id - 1 >= 0) neighbours.Add(id - 1);
        // Top
        if (IdIsInMap(id - MapWidth) && id - MapWidth >= 0) neighbours.Add(id - MapWidth);
        // Top Right / Left
        if (IdIsInMap(id - MapWidth + 1) && id - MapWidth + 1 >= 0) neighbours.Add(id - MapWidth + 1);
        if (IdIsInMap(id - MapWidth - 1) && id - MapWidth - 1 >= 0) neighbours.Add(id - MapWidth - 1);
        // Bot
        if (IdIsInMap(id + MapWidth) && id + MapWidth >= 0) neighbours.Add(id + MapWidth);
        // Bot Right / Left
        if (IdIsInMap(id + MapWidth + 1) && id + MapWidth + 1 >= 0) neighbours.Add(id + MapWidth + 1);
        if (IdIsInMap(id + MapWidth - 1) && id + MapWidth - 1 >= 0) neighbours.Add(id + MapWidth - 1);

        return neighbours.ToArray();
    }

    private void HandleRegionOccupied(Region region, Player occupier)
    {
        unoccupiedRegions.Remove(region.Id);
    }

    public static bool IdIsInMap(int id)
    {
        if (Instance == null) return false;
        return id < Instance.MapHeight * Instance.MapWidth;
    }

    public static Region GetRegion(int id)
    {
        if (Instance == null)
        {
            GD.PushError($"Couldn't get region with id {id}. Region manager isn't in scene yet.");
            return null;
        }

        if (!Instance.Regions.TryGetValue(id, out var region))
        {
            GD.PushError($"Couldn't get region with id {id}. Regions doesn't contain region with this id.");
            return null;
        }

        return region;
    }

    public static Region GetRandomUnoccupiedRegion()
    {
        if (Instance == null)
        {
            GD.PushError($"Couldn't get random unoccupied region. Region manager isn't in scene yet.");
            return null;
        }
        if (Instance.unoccupiedRegions.Keys.Count == 0)
        {
            GD.PushError($"Couldn't get random unoccupied region. There arent any left.");
            return null;
        }

        Random random = new Random();
        int index = random.Next(Instance.unoccupiedRegions.Keys.Count);
        return Instance.unoccupiedRegions[Instance.unoccupiedRegions.Keys.ToArray()[index]];
    }
}
